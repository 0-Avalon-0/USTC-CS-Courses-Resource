动态规划入门6
分类：算法与数据结构 

1.2背包问题

首先说说背包问题的基本模型：

现有N个物品，每个物品的价值为V，重量为W。求用一个载重量为S的背包装这写物品，使得所装物品的总价值最高。

背包问题用贪心和搜索解，当然效果不佳，不过在我的贪心和搜索总结中会说到。显然标准的解法是动态规化，我在解决这个问题时习惯设计一维状态，还可以设计二维的，二维状态在下面会讲，现在只讨论用一维状态实现背包问题。

背包问题的分类：

(1)小数背包:物品的重量是实数，如油，水等可以取1.67升……

                

(2)整数背包：<1>0/1背包：每个物品只能选一次，或不选。不能只选一部分

               <2>部分背包：所选物品可以是一部分。

(3)多重背包：背包不只一个。

小数背包：在贪心总结中会细讲。

整数背包：

  部分背包：同小数背包。

  0/1背包：这个问题是最经常出现的问题，应该熟练掌握。

我们先看一下0/1背包的简化版：

    现有N个物品，每个物品重量为W，这些物品能否使在载重量为S的背包装满（即重量和正好为S）？如过不能那能使物品重量和最重达到多少？

    针对这一问题我们以物品的个数分阶段，设计一个状态opt[i]表示载重量为i的背包可否装满，显然opt[i]的基类型是boolean。

决策是什么呢？

    当要装第i个物品时，如果前i-1个物品可以使载重为 k的背包装满，那么载重为k+w[i]的背包就可以装满。于是对于一个opt[j]来说，只要opt[j-w[i]]是true（表示可装满）那opt[j]就可以装满，但要注意：针对每一个物品枚举背包的载重量时如果这样正向的推导会使同一个物品用好几次，因为k+w[i]可装满那k+w[i]+w[i]就可装满，但实际上是装不满的因为物品只有一个。解决这个问题很简单，只要逆向推导就OK了。

这样划分阶段，设计状态，满足无后效性和么？

显然对与一个每一个阶段都是独立的，物品的顺序并不影响求解，因为装物品的次序不限。而对于opt[j]只考虑opt[j-w[i]]而不考虑后面的，所以满足无后效性。

有了上面的分析不难写出状态转移方程：

opt[j]:=opt[j-w[1]]  {opt[j-w[i]]=true}

时间复杂度：

阶段数O(S)*状态数（O(N)）*转移代价（O(1)）=O（SN）

下面看几个例题：

 

 

 例题5



装箱问题

                        (pack.pas/c/cpp)

                     来源：NOIP2001(普及组) 第四题

【问题描述】

有一个箱子容量为V（正整数，0＜＝V＜＝20000），同时有n个物品（0＜n＜＝30)，每个物品有一个体积（正整数）。

要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。

 

【输入文件】

    第一 行一个正整数V表示箱子的容量，第二行一个正整数N表示物品个数，接下来N行列出这N个物品各自的体积。

【输出文件】

    单独一行，表示箱子最小的剩余空间。

【输入样例】

24
6
8
3
12
7
9
7

【输出样例】

    0

【问题分析】

本题是经典的0/1背包问题，并且是0/1背包的简化版，把箱子看做背包，容量看做载重量，体积看做重量，剩余空间最小也就是尽量装满背包。于是这个问题便成了：

有一个栽重量为V的背包，有N个物品，尽量多装物品，使背包尽量的重。

设计一个状态opt[i]表示重量i可否构成。

状态转移方程：opt[j]:=opt[j-w[1]]  {opt[j-w[i]]=true}

最终的解就是v-x（x<=n 且opt[x]=true 且 opt[x+1..n]=false）。

【源代码1】

program packing;
var
	i,j,w,v,n:longint;
	f:array[0..100000]of longint;
begin
	assign(input,'input.txt'); reset(input);
	assign(output,'output.txt'); rewrite(output);
	readln(v);
	readln(n);
	for i:=1 to n do
	begin
		readln(w);
		for j:=v downto w do
		begin
			if f[j-w]+w>f[j] then f[j]:=f[j-w]+w;
		end;
	end;
	writeln(v-f[v]);
	close(input); close(output);
end.
